---
title: Concurrency Part 3- Level Up Your Go Concurrency Skills 
description: Master advanced synchronization tools, error handling techniques, and common design patterns for sophisticated concurrent Go applications. 
published: 1708632000000
slug: go-concurrency3
---

<ThemedImage filename="gocat.png" width={300} height={300} />

In the previous posts, we covered the basics of Go concurrency and how to use channels and goroutines to write concurrent programs. In this post, we will take a deep dive into advanced synchronization tools, error handling techniques, and common design patterns for sophisticated concurrent Go applications.

## Advanced Synchronization Tools

### WaitGroup

The <Snippet>sync.WaitGroup</Snippet> type is a powerful synchronization tool that allows you to wait for a collection of goroutines to complete. It is particularly useful when you need to wait for a group of goroutines to finish before proceeding to the next step in your program.

Here&apos;s an example of how to use <Snippet>sync.WaitGroup</Snippet>:

```go

package main

import (
    "fmt"
    "sync"
)


func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println("Hello from goroutine", i)
        }(i)
    }

    wg.Wait()
    fmt.Println("All goroutines have finished")
}
```

In this example, we create a <Snippet>sync.WaitGroup</Snippet> and call its <Snippet>Add</Snippet> method to add the number of goroutines we want to wait for. Then, we call the <Snippet>Wait</Snippet> method to block until all the goroutines have called <Snippet>Done</Snippet>.

### Mutex

The <Snippet>sync.Mutex</Snippet> type is a mutual exclusion lock that allows you to protect shared resources from concurrent access. It is particularly useful when you need to ensure that only one goroutine can access a resource at a time.

Here&apos;s an example of how to use <Snippet>sync.Mutex</Snippet>:

```go
package main

import (
    "fmt"
    "sync"
)

type Counter struct {
    mu sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func main() {
    var wg sync.WaitGroup
    counter := Counter{}

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    wg.Wait()
    fmt.Println("Counter value:", counter.Value())
}
```

In this example, we define a <Snippet>Counter</Snippet> type with a <Snippet>sync.Mutex</Snippet> field. We use the <Snippet>Lock</Snippet> and <Snippet>Unlock</Snippet> methods to protect the <Snippet>value</Snippet> field from concurrent access in the <Snippet>Increment</Snippet> and <Snippet>Value</Snippet> methods.

### RWMutex

The <Snippet>sync.RWMutex</Snippet> type is a reader/writer mutual exclusion lock that allows you to protect shared resources from concurrent access. It is particularly useful when you need to allow multiple goroutines to read a resource at the same time, but only one goroutine to write to it.

Here&apos;s an example of how to use <Snippet>sync.RWMutex</Snippet>:

```go

package main

import (
    "fmt"
    "sync"
)

type Cache struct {
    mu sync.RWMutex
    data map[string]string
}

func (c *Cache) Get(key string) string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.data[key]
}

func (c *Cache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}

func main() {
    cache := Cache{data: make(map[string]string)}

    cache.Set("foo", "bar")
    fmt.Println("Value of foo:", cache.Get("foo"))
}
```

In this example, we define a <Snippet>Cache</Snippet> type with a <Snippet>sync.RWMutex</Snippet> field. We use the <Snippet>RLock</Snippet> and <Snippet>RUnlock</Snippet> methods to protect the <Snippet>data</Snippet> field from concurrent read access in the <Snippet>Get</Snippet> method, and the <Snippet>Lock</Snippet> and <Snippet>Unlock</Snippet> methods to protect it from concurrent write access in the <Snippet>Set</Snippet> method.

## Error Handling Techniques

### Error Groups

The <Snippet>errgroup</Snippet> package in the <Snippet>golang.org/x/sync</Snippet> module provides a convenient way to handle errors from a group of goroutines. It allows you to run a collection of goroutines and return the first error encountered.

Here&apos;s an example of how to use <Snippet>errgroup</Snippet>:

```go

package main

import (
    "fmt"
    "golang.org/x/sync/errgroup"
)

func main() {
    g := new(errgroup.Group)

    for i := 0; i < 5; i++ {
        i := i
        g.Go(func() error {
            if i == 3 {
                return fmt.Errorf("goroutine %d failed", i)
            }
            fmt.Println("Hello from goroutine", i)
            return nil
        })
    }

    if err := g.Wait(); err != nil {
        fmt.Println("Error:", err)
    }
}
```

In this example, we create an <Snippet>errgroup.Group</Snippet> and call its <Snippet>Go</Snippet> method to add the number of goroutines we want to run. Then, we call the <Snippet>Wait</Snippet> method to block until all the goroutines have finished, and check if there was an error.

### Error Channels

You can use channels to propagate errors from goroutines to the main function. This allows you to handle errors in a centralized location and avoid the need for complex error handling logic in each goroutine.

Here&apos;s an example of how to use error channels:

```go

package main

import (
    "fmt"
)

func worker(ch chan<- error) {
    if err := doWork(); err != nil {
        ch <- err
        return
    }
    ch <- nil
}

func doWork() error {
    // ...
    return nil
}

func main() {
    ch := make(chan error, 1)

    go worker(ch)

    if err := <-ch; err != nil {
        fmt.Println("Error:", err)
    }
}
```

In this example, we define a <Snippet>worker</Snippet> function that takes an error channel as an argument. If an error occurs during the work, it sends the error to the channel. Then, in the main function, we create an error channel and start the worker goroutine. We use a select statement to wait for the error to be sent on the channel and handle it if it occurs.

## Common Design Patterns

### Fan-In

The fan-in pattern is a common design pattern for combining the output of multiple goroutines into a single channel. It is particularly useful when you need to process data from multiple sources concurrently.

Here&apos;s an example of how to use the fan-in pattern:

```go

package main

import (
    "fmt"
)

func producer(ch chan<- int) {
    for i := 0; i < 5; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for v := range ch {
        fmt.Println("Received value:", v)
    }
}

func main() {
    ch := make(chan int)

    go producer(ch)
    go consumer(ch)

    // Wait for the goroutines to finish
    // ...
}
```

In this example, we define a <Snippet>producer</Snippet> function that sends values to a channel, and a <Snippet>consumer</Snippet> function that receives values from the channel. Then, in the main function, we create a channel and start the producer and consumer goroutines. We use a select statement to wait for the goroutines to finish.

### Fan-Out

The fan-out pattern is a common design pattern for distributing the work of a single goroutine to multiple worker goroutines. It is particularly useful when you need to process a large amount of data concurrently.

Here&apos;s an example of how to use the fan-out pattern:

```go

package main

import (
    "fmt"
)

func worker(id int, in <-chan int, out chan<- int) {
    for v := range in {
        out <- v * 2
    }
    close(out)
}

func main() {
    in := make(chan int)
    out := make(chan int)

    for i := 0; i < 5; i++ {
        go worker(i, in, out)
    }

    go func() {
        for i := 0; i < 5; i++ {
            in <- i
        }
        close(in)
    }()

    for v := range out {
        fmt.Println("Received value:", v)
    }
}
```

In this example, we define a <Snippet>worker</Snippet> function that receives values from an input channel, processes them, and sends the results to an output channel. Then, in the main function, we create input and output channels and start multiple worker goroutines. We use a select statement to wait for the results to be sent on the output channel.

### Pipeline

The pipeline pattern is a common design pattern for connecting multiple stages of processing using channels. It is particularly useful when you need to process data in a series of steps.

Here&apos;s an example of how to use the pipeline pattern:

```go

package main

import (
    "fmt"
)

func producer(out chan<- int) {
    for i := 0; i < 5; i++ {
        out <- i
    }
    close(out)
}

func doubler(in <-chan int, out chan<- int) {
    for v := range in {
        out <- v * 2
    }
    close(out)
}

func consumer(in <-chan int) {
    for v := range in {
        fmt.Println("Received value:", v)
    }
}

func main() {
    out := make(chan int)
    out2 := make(chan int)

    go producer(out)
    go doubler(out, out2)
    go consumer(out2)

    // Wait for the goroutines to finish
    // ...
}
```

In this example, we define a <Snippet>producer</Snippet> function that sends values to an output channel, a <Snippet>doubler</Snippet> function that receives values from an input channel, processes them, and sends the results to an output channel, and a <Snippet>consumer</Snippet> function that receives values from an input channel. Then, in the main function, we create input and output channels and start the producer, doubler, and consumer goroutines. We use a select statement to wait for the goroutines to finish.

## Conclusion

In this post, we covered advanced synchronization tools, error handling techniques, and common design patterns for sophisticated concurrent Go applications.

We learned how to use <Snippet>sync.WaitGroup</Snippet> to wait for a collection of goroutines to complete, <Snippet>sync.Mutex</Snippet> to protect shared resources from concurrent access, and <Snippet>sync.RWMutex</Snippet> to allow multiple goroutines to read a resource at the same time, but only one goroutine to write to it.

We also learned how to use the <Snippet>errgroup</Snippet> package to handle errors from a group of goroutines, and error channels to propagate errors from goroutines to the main function.

Finally, we learned about common design patterns such as fan-in, fan-out, and pipeline, and how to use them to write concurrent Go programs.


I hope this post has provided you with some useful insights! 

{/* If you have any questions or feedback, please feel free to reach out to me on [Twitter](https://twitter.com/codewitty_).  */}

Happy coding in Go! 

<ThemedImage filename="gopher.gif" width={300} height={300} /> 