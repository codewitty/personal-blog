"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-entities";
exports.ids = ["vendor-chunks/parse-entities"];
exports.modules = {

/***/ "(rsc)/./node_modules/parse-entities/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/parse-entities/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseEntities: () => (/* binding */ parseEntities)\n/* harmony export */ });\n/* harmony import */ var character_entities_legacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! character-entities-legacy */ \"(rsc)/./node_modules/character-entities-legacy/index.js\");\n/* harmony import */ var character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! character-reference-invalid */ \"(rsc)/./node_modules/character-reference-invalid/index.js\");\n/* harmony import */ var is_decimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-decimal */ \"(rsc)/./node_modules/is-decimal/index.js\");\n/* harmony import */ var is_hexadecimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-hexadecimal */ \"(rsc)/./node_modules/is-hexadecimal/index.js\");\n/* harmony import */ var is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-alphanumerical */ \"(rsc)/./node_modules/is-alphanumerical/index.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! decode-named-character-reference */ \"(rsc)/./node_modules/decode-named-character-reference/index.js\");\n/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */ \n\n\n\n\n\nconst fromCharCode = String.fromCharCode;\n// Warning messages.\nconst messages = [\n    \"\",\n    /* 1: Non terminated (named) */ \"Named character references must be terminated by a semicolon\",\n    /* 2: Non terminated (numeric) */ \"Numeric character references must be terminated by a semicolon\",\n    /* 3: Empty (named) */ \"Named character references cannot be empty\",\n    /* 4: Empty (numeric) */ \"Numeric character references cannot be empty\",\n    /* 5: Unknown (named) */ \"Named character references must be known\",\n    /* 6: Disallowed (numeric) */ \"Numeric character references cannot be disallowed\",\n    /* 7: Prohibited (numeric) */ \"Numeric character references cannot be outside the permissible Unicode range\"\n];\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */ function parseEntities(value, options = {}) {\n    const additional = typeof options.additional === \"string\" ? options.additional.charCodeAt(0) : options.additional;\n    /** @type {Array<string>} */ const result = [];\n    let index = 0;\n    let lines = -1;\n    let queue = \"\";\n    /** @type {Point|undefined} */ let point;\n    /** @type {Array<number>|undefined} */ let indent;\n    if (options.position) {\n        if (\"start\" in options.position || \"indent\" in options.position) {\n            // @ts-expect-error: points don’t have indent.\n            indent = options.position.indent;\n            // @ts-expect-error: points don’t have indent.\n            point = options.position.start;\n        } else {\n            point = options.position;\n        }\n    }\n    let line = (point ? point.line : 0) || 1;\n    let column = (point ? point.column : 0) || 1;\n    // Cache the current point.\n    let previous = now();\n    /** @type {number|undefined} */ let character;\n    // Ensure the algorithm walks over the first character (inclusive).\n    index--;\n    while(++index <= value.length){\n        // If the previous character was a newline.\n        if (character === 10 /* `\\n` */ ) {\n            column = (indent ? indent[lines] : 0) || 1;\n        }\n        character = value.charCodeAt(index);\n        if (character === 38 /* `&` */ ) {\n            const following = value.charCodeAt(index + 1);\n            // The behavior depends on the identity of the next character.\n            if (following === 9 /* `\\t` */  || following === 10 /* `\\n` */  || following === 12 /* `\\f` */  || following === 32 /* ` ` */  || following === 38 /* `&` */  || following === 60 /* `<` */  || Number.isNaN(following) || additional && following === additional) {\n                // Not a character reference.\n                // No characters are consumed, and nothing is returned.\n                // This is not an error, either.\n                queue += fromCharCode(character);\n                column++;\n                continue;\n            }\n            const start = index + 1;\n            let begin = start;\n            let end = start;\n            /** @type {string} */ let type;\n            if (following === 35 /* `#` */ ) {\n                // Numerical reference.\n                end = ++begin;\n                // The behavior further depends on the next character.\n                const following = value.charCodeAt(end);\n                if (following === 88 /* `X` */  || following === 120 /* `x` */ ) {\n                    // ASCII hexadecimal digits.\n                    type = \"hexadecimal\";\n                    end = ++begin;\n                } else {\n                    // ASCII decimal digits.\n                    type = \"decimal\";\n                }\n            } else {\n                // Named reference.\n                type = \"named\";\n            }\n            let characterReferenceCharacters = \"\";\n            let characterReference = \"\";\n            let characters = \"\";\n            // Each type of character reference accepts different characters.\n            // This test is used to detect whether a reference has ended (as the semicolon\n            // is not strictly needed).\n            const test = type === \"named\" ? is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__.isAlphanumerical : type === \"decimal\" ? is_decimal__WEBPACK_IMPORTED_MODULE_1__.isDecimal : is_hexadecimal__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal;\n            end--;\n            while(++end <= value.length){\n                const following = value.charCodeAt(end);\n                if (!test(following)) {\n                    break;\n                }\n                characters += fromCharCode(following);\n                // Check if we can match a legacy named reference.\n                // If so, we cache that as the last viable named reference.\n                // This ensures we do not need to walk backwards later.\n                if (type === \"named\" && character_entities_legacy__WEBPACK_IMPORTED_MODULE_3__.characterEntitiesLegacy.includes(characters)) {\n                    characterReferenceCharacters = characters;\n                    // @ts-expect-error: always able to decode.\n                    characterReference = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__.decodeNamedCharacterReference)(characters);\n                }\n            }\n            let terminated = value.charCodeAt(end) === 59 /* `;` */ ;\n            if (terminated) {\n                end++;\n                const namedReference = type === \"named\" ? (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__.decodeNamedCharacterReference)(characters) : false;\n                if (namedReference) {\n                    characterReferenceCharacters = characters;\n                    characterReference = namedReference;\n                }\n            }\n            let diff = 1 + end - start;\n            let reference = \"\";\n            if (!terminated && options.nonTerminated === false) {\n            // Empty.\n            } else if (!characters) {\n                // An empty (possible) reference is valid, unless it’s numeric (thus an\n                // ampersand followed by an octothorp).\n                if (type !== \"named\") {\n                    warning(4 /* Empty (numeric) */ , diff);\n                }\n            } else if (type === \"named\") {\n                // An ampersand followed by anything unknown, and not terminated, is\n                // invalid.\n                if (terminated && !characterReference) {\n                    warning(5 /* Unknown (named) */ , 1);\n                } else {\n                    // If there’s something after an named reference which is not known,\n                    // cap the reference.\n                    if (characterReferenceCharacters !== characters) {\n                        end = begin + characterReferenceCharacters.length;\n                        diff = 1 + end - begin;\n                        terminated = false;\n                    }\n                    // If the reference is not terminated, warn.\n                    if (!terminated) {\n                        const reason = characterReferenceCharacters ? 1 /* Non terminated (named) */  : 3 /* Empty (named) */ ;\n                        if (options.attribute) {\n                            const following = value.charCodeAt(end);\n                            if (following === 61 /* `=` */ ) {\n                                warning(reason, diff);\n                                characterReference = \"\";\n                            } else if ((0,is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__.isAlphanumerical)(following)) {\n                                characterReference = \"\";\n                            } else {\n                                warning(reason, diff);\n                            }\n                        } else {\n                            warning(reason, diff);\n                        }\n                    }\n                }\n                reference = characterReference;\n            } else {\n                if (!terminated) {\n                    // All nonterminated numeric references are not rendered, and emit a\n                    // warning.\n                    warning(2 /* Non terminated (numeric) */ , diff);\n                }\n                // When terminated and numerical, parse as either hexadecimal or\n                // decimal.\n                let referenceCode = Number.parseInt(characters, type === \"hexadecimal\" ? 16 : 10);\n                // Emit a warning when the parsed number is prohibited, and replace with\n                // replacement character.\n                if (prohibited(referenceCode)) {\n                    warning(7 /* Prohibited (numeric) */ , diff);\n                    reference = fromCharCode(65533 /* `�` */ );\n                } else if (referenceCode in character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__.characterReferenceInvalid) {\n                    // Emit a warning when the parsed number is disallowed, and replace by\n                    // an alternative.\n                    warning(6 /* Disallowed (numeric) */ , diff);\n                    reference = character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__.characterReferenceInvalid[referenceCode];\n                } else {\n                    // Parse the number.\n                    let output = \"\";\n                    // Emit a warning when the parsed number should not be used.\n                    if (disallowed(referenceCode)) {\n                        warning(6 /* Disallowed (numeric) */ , diff);\n                    }\n                    // Serialize the number.\n                    if (referenceCode > 0xffff) {\n                        referenceCode -= 0x10000;\n                        output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n                        referenceCode = 0xdc00 | referenceCode & 0x3ff;\n                    }\n                    reference = output + fromCharCode(referenceCode);\n                }\n            }\n            // Found it!\n            // First eat the queued characters as normal text, then eat a reference.\n            if (reference) {\n                flush();\n                previous = now();\n                index = end - 1;\n                column += end - start + 1;\n                result.push(reference);\n                const next = now();\n                next.offset++;\n                if (options.reference) {\n                    options.reference.call(options.referenceContext, reference, {\n                        start: previous,\n                        end: next\n                    }, value.slice(start - 1, end));\n                }\n                previous = next;\n            } else {\n                // If we could not find a reference, queue the checked characters (as\n                // normal characters), and move the pointer to their end.\n                // This is possible because we can be certain neither newlines nor\n                // ampersands are included.\n                characters = value.slice(start - 1, end);\n                queue += characters;\n                column += characters.length;\n                index = end - 1;\n            }\n        } else {\n            // Handle anything other than an ampersand, including newlines and EOF.\n            if (character === 10 /* `\\n` */ ) {\n                line++;\n                lines++;\n                column = 0;\n            }\n            if (Number.isNaN(character)) {\n                flush();\n            } else {\n                queue += fromCharCode(character);\n                column++;\n            }\n        }\n    }\n    // Return the reduced nodes.\n    return result.join(\"\");\n    // Get current position.\n    function now() {\n        return {\n            line,\n            column,\n            offset: index + ((point ? point.offset : 0) || 0)\n        };\n    }\n    /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */ function warning(code, offset) {\n        /** @type {ReturnType<now>} */ let position;\n        if (options.warning) {\n            position = now();\n            position.column += offset;\n            position.offset += offset;\n            options.warning.call(options.warningContext, messages[code], position, code);\n        }\n    }\n    /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */ function flush() {\n        if (queue) {\n            result.push(queue);\n            if (options.text) {\n                options.text.call(options.textContext, queue, {\n                    start: previous,\n                    end: now()\n                });\n            }\n            queue = \"\";\n        }\n    }\n}\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */ function prohibited(code) {\n    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */ function disallowed(code) {\n    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGFyc2UtZW50aXRpZXMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFZ0U7QUFDSTtBQUNqQztBQUNRO0FBQ007QUFDNEI7QUFFOUUsTUFBTU0sZUFBZUMsT0FBT0QsWUFBWTtBQUV4QyxvQkFBb0I7QUFDcEIsTUFBTUUsV0FBVztJQUNmO0lBQ0EsNkJBQTZCLEdBQzdCO0lBQ0EsK0JBQStCLEdBQy9CO0lBQ0Esb0JBQW9CLEdBQ3BCO0lBQ0Esc0JBQXNCLEdBQ3RCO0lBQ0Esc0JBQXNCLEdBQ3RCO0lBQ0EsMkJBQTJCLEdBQzNCO0lBQ0EsMkJBQTJCLEdBQzNCO0NBQ0Q7QUFFRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsTUFBTUMsYUFDSixPQUFPRCxRQUFRQyxVQUFVLEtBQUssV0FDMUJELFFBQVFDLFVBQVUsQ0FBQ0MsVUFBVSxDQUFDLEtBQzlCRixRQUFRQyxVQUFVO0lBQ3hCLDBCQUEwQixHQUMxQixNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLFFBQVE7SUFDWiw0QkFBNEIsR0FDNUIsSUFBSUM7SUFDSixvQ0FBb0MsR0FDcEMsSUFBSUM7SUFFSixJQUFJUixRQUFRUyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxXQUFXVCxRQUFRUyxRQUFRLElBQUksWUFBWVQsUUFBUVMsUUFBUSxFQUFFO1lBQy9ELDhDQUE4QztZQUM5Q0QsU0FBU1IsUUFBUVMsUUFBUSxDQUFDRCxNQUFNO1lBQ2hDLDhDQUE4QztZQUM5Q0QsUUFBUVAsUUFBUVMsUUFBUSxDQUFDQyxLQUFLO1FBQ2hDLE9BQU87WUFDTEgsUUFBUVAsUUFBUVMsUUFBUTtRQUMxQjtJQUNGO0lBRUEsSUFBSUUsT0FBTyxDQUFDSixRQUFRQSxNQUFNSSxJQUFJLEdBQUcsTUFBTTtJQUN2QyxJQUFJQyxTQUFTLENBQUNMLFFBQVFBLE1BQU1LLE1BQU0sR0FBRyxNQUFNO0lBRTNDLDJCQUEyQjtJQUMzQixJQUFJQyxXQUFXQztJQUNmLDZCQUE2QixHQUM3QixJQUFJQztJQUVKLG1FQUFtRTtJQUNuRVg7SUFFQSxNQUFPLEVBQUVBLFNBQVNMLE1BQU1pQixNQUFNLENBQUU7UUFDOUIsMkNBQTJDO1FBQzNDLElBQUlELGNBQWMsR0FBRyxRQUFRLEtBQUk7WUFDL0JILFNBQVMsQ0FBQ0osU0FBU0EsTUFBTSxDQUFDSCxNQUFNLEdBQUcsTUFBTTtRQUMzQztRQUVBVSxZQUFZaEIsTUFBTUcsVUFBVSxDQUFDRTtRQUU3QixJQUFJVyxjQUFjLEdBQUcsT0FBTyxLQUFJO1lBQzlCLE1BQU1FLFlBQVlsQixNQUFNRyxVQUFVLENBQUNFLFFBQVE7WUFFM0MsOERBQThEO1lBQzlELElBQ0VhLGNBQWMsRUFBRSxRQUFRLE9BQ3hCQSxjQUFjLEdBQUcsUUFBUSxPQUN6QkEsY0FBYyxHQUFHLFFBQVEsT0FDekJBLGNBQWMsR0FBRyxPQUFPLE9BQ3hCQSxjQUFjLEdBQUcsT0FBTyxPQUN4QkEsY0FBYyxHQUFHLE9BQU8sT0FDeEJDLE9BQU9DLEtBQUssQ0FBQ0YsY0FDWmhCLGNBQWNnQixjQUFjaEIsWUFDN0I7Z0JBQ0EsNkJBQTZCO2dCQUM3Qix1REFBdUQ7Z0JBQ3ZELGdDQUFnQztnQkFDaENLLFNBQVNYLGFBQWFvQjtnQkFDdEJIO2dCQUNBO1lBQ0Y7WUFFQSxNQUFNRixRQUFRTixRQUFRO1lBQ3RCLElBQUlnQixRQUFRVjtZQUNaLElBQUlXLE1BQU1YO1lBQ1YsbUJBQW1CLEdBQ25CLElBQUlZO1lBRUosSUFBSUwsY0FBYyxHQUFHLE9BQU8sS0FBSTtnQkFDOUIsdUJBQXVCO2dCQUN2QkksTUFBTSxFQUFFRDtnQkFFUixzREFBc0Q7Z0JBQ3RELE1BQU1ILFlBQVlsQixNQUFNRyxVQUFVLENBQUNtQjtnQkFFbkMsSUFBSUosY0FBYyxHQUFHLE9BQU8sT0FBTUEsY0FBYyxJQUFJLE9BQU8sS0FBSTtvQkFDN0QsNEJBQTRCO29CQUM1QkssT0FBTztvQkFDUEQsTUFBTSxFQUFFRDtnQkFDVixPQUFPO29CQUNMLHdCQUF3QjtvQkFDeEJFLE9BQU87Z0JBQ1Q7WUFDRixPQUFPO2dCQUNMLG1CQUFtQjtnQkFDbkJBLE9BQU87WUFDVDtZQUVBLElBQUlDLCtCQUErQjtZQUNuQyxJQUFJQyxxQkFBcUI7WUFDekIsSUFBSUMsYUFBYTtZQUNqQixpRUFBaUU7WUFDakUsOEVBQThFO1lBQzlFLDJCQUEyQjtZQUMzQixNQUFNQyxPQUNKSixTQUFTLFVBQ0w3QiwrREFBZ0JBLEdBQ2hCNkIsU0FBUyxZQUNUL0IsaURBQVNBLEdBQ1RDLHlEQUFhQTtZQUVuQjZCO1lBRUEsTUFBTyxFQUFFQSxPQUFPdEIsTUFBTWlCLE1BQU0sQ0FBRTtnQkFDNUIsTUFBTUMsWUFBWWxCLE1BQU1HLFVBQVUsQ0FBQ21CO2dCQUVuQyxJQUFJLENBQUNLLEtBQUtULFlBQVk7b0JBQ3BCO2dCQUNGO2dCQUVBUSxjQUFjOUIsYUFBYXNCO2dCQUUzQixrREFBa0Q7Z0JBQ2xELDJEQUEyRDtnQkFDM0QsdURBQXVEO2dCQUN2RCxJQUFJSyxTQUFTLFdBQVdqQyw4RUFBdUJBLENBQUNzQyxRQUFRLENBQUNGLGFBQWE7b0JBQ3BFRiwrQkFBK0JFO29CQUMvQiwyQ0FBMkM7b0JBQzNDRCxxQkFBcUI5QiwrRkFBNkJBLENBQUMrQjtnQkFDckQ7WUFDRjtZQUVBLElBQUlHLGFBQWE3QixNQUFNRyxVQUFVLENBQUNtQixTQUFTLEdBQUcsT0FBTztZQUVyRCxJQUFJTyxZQUFZO2dCQUNkUDtnQkFFQSxNQUFNUSxpQkFDSlAsU0FBUyxVQUFVNUIsK0ZBQTZCQSxDQUFDK0IsY0FBYztnQkFFakUsSUFBSUksZ0JBQWdCO29CQUNsQk4sK0JBQStCRTtvQkFDL0JELHFCQUFxQks7Z0JBQ3ZCO1lBQ0Y7WUFFQSxJQUFJQyxPQUFPLElBQUlULE1BQU1YO1lBQ3JCLElBQUlxQixZQUFZO1lBRWhCLElBQUksQ0FBQ0gsY0FBYzVCLFFBQVFnQyxhQUFhLEtBQUssT0FBTztZQUNsRCxTQUFTO1lBQ1gsT0FBTyxJQUFJLENBQUNQLFlBQVk7Z0JBQ3RCLHVFQUF1RTtnQkFDdkUsdUNBQXVDO2dCQUN2QyxJQUFJSCxTQUFTLFNBQVM7b0JBQ3BCVyxRQUFRLEVBQUUsbUJBQW1CLEtBQUlIO2dCQUNuQztZQUNGLE9BQU8sSUFBSVIsU0FBUyxTQUFTO2dCQUMzQixvRUFBb0U7Z0JBQ3BFLFdBQVc7Z0JBQ1gsSUFBSU0sY0FBYyxDQUFDSixvQkFBb0I7b0JBQ3JDUyxRQUFRLEVBQUUsbUJBQW1CLEtBQUk7Z0JBQ25DLE9BQU87b0JBQ0wsb0VBQW9FO29CQUNwRSxxQkFBcUI7b0JBQ3JCLElBQUlWLGlDQUFpQ0UsWUFBWTt3QkFDL0NKLE1BQU1ELFFBQVFHLDZCQUE2QlAsTUFBTTt3QkFDakRjLE9BQU8sSUFBSVQsTUFBTUQ7d0JBQ2pCUSxhQUFhO29CQUNmO29CQUVBLDRDQUE0QztvQkFDNUMsSUFBSSxDQUFDQSxZQUFZO3dCQUNmLE1BQU1NLFNBQVNYLCtCQUNYLEVBQUUsMEJBQTBCLE1BQzVCLEVBQUUsaUJBQWlCO3dCQUV2QixJQUFJdkIsUUFBUW1DLFNBQVMsRUFBRTs0QkFDckIsTUFBTWxCLFlBQVlsQixNQUFNRyxVQUFVLENBQUNtQjs0QkFFbkMsSUFBSUosY0FBYyxHQUFHLE9BQU8sS0FBSTtnQ0FDOUJnQixRQUFRQyxRQUFRSjtnQ0FDaEJOLHFCQUFxQjs0QkFDdkIsT0FBTyxJQUFJL0IsbUVBQWdCQSxDQUFDd0IsWUFBWTtnQ0FDdENPLHFCQUFxQjs0QkFDdkIsT0FBTztnQ0FDTFMsUUFBUUMsUUFBUUo7NEJBQ2xCO3dCQUNGLE9BQU87NEJBQ0xHLFFBQVFDLFFBQVFKO3dCQUNsQjtvQkFDRjtnQkFDRjtnQkFFQUMsWUFBWVA7WUFDZCxPQUFPO2dCQUNMLElBQUksQ0FBQ0ksWUFBWTtvQkFDZixvRUFBb0U7b0JBQ3BFLFdBQVc7b0JBQ1hLLFFBQVEsRUFBRSw0QkFBNEIsS0FBSUg7Z0JBQzVDO2dCQUVBLGdFQUFnRTtnQkFDaEUsV0FBVztnQkFDWCxJQUFJTSxnQkFBZ0JsQixPQUFPbUIsUUFBUSxDQUNqQ1osWUFDQUgsU0FBUyxnQkFBZ0IsS0FBSztnQkFHaEMsd0VBQXdFO2dCQUN4RSx5QkFBeUI7Z0JBQ3pCLElBQUlnQixXQUFXRixnQkFBZ0I7b0JBQzdCSCxRQUFRLEVBQUUsd0JBQXdCLEtBQUlIO29CQUN0Q0MsWUFBWXBDLGFBQWEsTUFBTSxPQUFPO2dCQUN4QyxPQUFPLElBQUl5QyxpQkFBaUI5QyxrRkFBeUJBLEVBQUU7b0JBQ3JELHNFQUFzRTtvQkFDdEUsa0JBQWtCO29CQUNsQjJDLFFBQVEsRUFBRSx3QkFBd0IsS0FBSUg7b0JBQ3RDQyxZQUFZekMsa0ZBQXlCLENBQUM4QyxjQUFjO2dCQUN0RCxPQUFPO29CQUNMLG9CQUFvQjtvQkFDcEIsSUFBSUcsU0FBUztvQkFFYiw0REFBNEQ7b0JBQzVELElBQUlDLFdBQVdKLGdCQUFnQjt3QkFDN0JILFFBQVEsRUFBRSx3QkFBd0IsS0FBSUg7b0JBQ3hDO29CQUVBLHdCQUF3QjtvQkFDeEIsSUFBSU0sZ0JBQWdCLFFBQVE7d0JBQzFCQSxpQkFBaUI7d0JBQ2pCRyxVQUFVNUMsYUFBYSxrQkFBb0IsTUFBSyxLQUFJLElBQU07d0JBQzFEeUMsZ0JBQWdCLFNBQVVBLGdCQUFnQjtvQkFDNUM7b0JBRUFMLFlBQVlRLFNBQVM1QyxhQUFheUM7Z0JBQ3BDO1lBQ0Y7WUFFQSxZQUFZO1lBQ1osd0VBQXdFO1lBQ3hFLElBQUlMLFdBQVc7Z0JBQ2JVO2dCQUVBNUIsV0FBV0M7Z0JBQ1hWLFFBQVFpQixNQUFNO2dCQUNkVCxVQUFVUyxNQUFNWCxRQUFRO2dCQUN4QlAsT0FBT3VDLElBQUksQ0FBQ1g7Z0JBQ1osTUFBTVksT0FBTzdCO2dCQUNiNkIsS0FBS0MsTUFBTTtnQkFFWCxJQUFJNUMsUUFBUStCLFNBQVMsRUFBRTtvQkFDckIvQixRQUFRK0IsU0FBUyxDQUFDYyxJQUFJLENBQ3BCN0MsUUFBUThDLGdCQUFnQixFQUN4QmYsV0FDQTt3QkFBQ3JCLE9BQU9HO3dCQUFVUSxLQUFLc0I7b0JBQUksR0FDM0I1QyxNQUFNZ0QsS0FBSyxDQUFDckMsUUFBUSxHQUFHVztnQkFFM0I7Z0JBRUFSLFdBQVc4QjtZQUNiLE9BQU87Z0JBQ0wscUVBQXFFO2dCQUNyRSx5REFBeUQ7Z0JBQ3pELGtFQUFrRTtnQkFDbEUsMkJBQTJCO2dCQUMzQmxCLGFBQWExQixNQUFNZ0QsS0FBSyxDQUFDckMsUUFBUSxHQUFHVztnQkFDcENmLFNBQVNtQjtnQkFDVGIsVUFBVWEsV0FBV1QsTUFBTTtnQkFDM0JaLFFBQVFpQixNQUFNO1lBQ2hCO1FBQ0YsT0FBTztZQUNMLHVFQUF1RTtZQUN2RSxJQUFJTixjQUFjLEdBQUcsUUFBUSxLQUFJO2dCQUMvQko7Z0JBQ0FOO2dCQUNBTyxTQUFTO1lBQ1g7WUFFQSxJQUFJTSxPQUFPQyxLQUFLLENBQUNKLFlBQVk7Z0JBQzNCMEI7WUFDRixPQUFPO2dCQUNMbkMsU0FBU1gsYUFBYW9CO2dCQUN0Qkg7WUFDRjtRQUNGO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsT0FBT1QsT0FBTzZDLElBQUksQ0FBQztJQUVuQix3QkFBd0I7SUFDeEIsU0FBU2xDO1FBQ1AsT0FBTztZQUNMSDtZQUNBQztZQUNBZ0MsUUFBUXhDLFFBQVMsRUFBQ0csUUFBUUEsTUFBTXFDLE1BQU0sR0FBRyxNQUFNO1FBQ2pEO0lBQ0Y7SUFFQTs7Ozs7R0FLQyxHQUNELFNBQVNYLFFBQVFnQixJQUFJLEVBQUVMLE1BQU07UUFDM0IsNEJBQTRCLEdBQzVCLElBQUluQztRQUVKLElBQUlULFFBQVFpQyxPQUFPLEVBQUU7WUFDbkJ4QixXQUFXSztZQUNYTCxTQUFTRyxNQUFNLElBQUlnQztZQUNuQm5DLFNBQVNtQyxNQUFNLElBQUlBO1lBRW5CNUMsUUFBUWlDLE9BQU8sQ0FBQ1ksSUFBSSxDQUNsQjdDLFFBQVFrRCxjQUFjLEVBQ3RCckQsUUFBUSxDQUFDb0QsS0FBSyxFQUNkeEMsVUFDQXdDO1FBRUo7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxTQUFTUjtRQUNQLElBQUluQyxPQUFPO1lBQ1RILE9BQU91QyxJQUFJLENBQUNwQztZQUVaLElBQUlOLFFBQVFtRCxJQUFJLEVBQUU7Z0JBQ2hCbkQsUUFBUW1ELElBQUksQ0FBQ04sSUFBSSxDQUFDN0MsUUFBUW9ELFdBQVcsRUFBRTlDLE9BQU87b0JBQzVDSSxPQUFPRztvQkFDUFEsS0FBS1A7Z0JBQ1A7WUFDRjtZQUVBUixRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTZ0MsV0FBV1csSUFBSTtJQUN0QixPQUFPLFFBQVMsVUFBVUEsUUFBUSxVQUFXQSxPQUFPO0FBQ3REO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTVCxXQUFXUyxJQUFJO0lBQ3RCLE9BQ0UsUUFBUyxVQUFVQSxRQUFRLFVBQzNCQSxTQUFTLFVBQ1JBLFFBQVEsVUFBVUEsUUFBUSxVQUMxQkEsUUFBUSxVQUFVQSxRQUFRLFVBQzFCQSxRQUFRLFVBQVVBLFFBQVEsVUFDM0IsQ0FBQ0EsT0FBTyxNQUFLLE1BQU8sVUFDcEIsQ0FBQ0EsT0FBTyxNQUFLLE1BQU87QUFFeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9nLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWVudGl0aWVzL2xpYi9pbmRleC5qcz9hMzhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9zaXRpb259IFBvc2l0aW9uXG4gKi9cblxuaW1wb3J0IHtjaGFyYWN0ZXJFbnRpdGllc0xlZ2FjeX0gZnJvbSAnY2hhcmFjdGVyLWVudGl0aWVzLWxlZ2FjeSdcbmltcG9ydCB7Y2hhcmFjdGVyUmVmZXJlbmNlSW52YWxpZH0gZnJvbSAnY2hhcmFjdGVyLXJlZmVyZW5jZS1pbnZhbGlkJ1xuaW1wb3J0IHtpc0RlY2ltYWx9IGZyb20gJ2lzLWRlY2ltYWwnXG5pbXBvcnQge2lzSGV4YWRlY2ltYWx9IGZyb20gJ2lzLWhleGFkZWNpbWFsJ1xuaW1wb3J0IHtpc0FscGhhbnVtZXJpY2FsfSBmcm9tICdpcy1hbHBoYW51bWVyaWNhbCdcbmltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuXG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5cbi8vIFdhcm5pbmcgbWVzc2FnZXMuXG5jb25zdCBtZXNzYWdlcyA9IFtcbiAgJycsXG4gIC8qIDE6IE5vbiB0ZXJtaW5hdGVkIChuYW1lZCkgKi9cbiAgJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicsXG4gIC8qIDI6IE5vbiB0ZXJtaW5hdGVkIChudW1lcmljKSAqL1xuICAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBtdXN0IGJlIHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nLFxuICAvKiAzOiBFbXB0eSAobmFtZWQpICovXG4gICdOYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgZW1wdHknLFxuICAvKiA0OiBFbXB0eSAobnVtZXJpYykgKi9cbiAgJ051bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZXMgY2Fubm90IGJlIGVtcHR5JyxcbiAgLyogNTogVW5rbm93biAobmFtZWQpICovXG4gICdOYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBtdXN0IGJlIGtub3duJyxcbiAgLyogNjogRGlzYWxsb3dlZCAobnVtZXJpYykgKi9cbiAgJ051bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZXMgY2Fubm90IGJlIGRpc2FsbG93ZWQnLFxuICAvKiA3OiBQcm9oaWJpdGVkIChudW1lcmljKSAqL1xuICAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgb3V0c2lkZSB0aGUgcGVybWlzc2libGUgVW5pY29kZSByYW5nZSdcbl1cblxuLyoqXG4gKiBQYXJzZSBIVE1MIGNoYXJhY3RlciByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuT3B0aW9uc30gW29wdGlvbnM9e31dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVudGl0aWVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYWRkaXRpb25hbCA9XG4gICAgdHlwZW9mIG9wdGlvbnMuYWRkaXRpb25hbCA9PT0gJ3N0cmluZydcbiAgICAgID8gb3B0aW9ucy5hZGRpdGlvbmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIDogb3B0aW9ucy5hZGRpdGlvbmFsXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgbGV0IGluZGV4ID0gMFxuICBsZXQgbGluZXMgPSAtMVxuICBsZXQgcXVldWUgPSAnJ1xuICAvKiogQHR5cGUge1BvaW50fHVuZGVmaW5lZH0gKi9cbiAgbGV0IHBvaW50XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9ICovXG4gIGxldCBpbmRlbnRcblxuICBpZiAob3B0aW9ucy5wb3NpdGlvbikge1xuICAgIGlmICgnc3RhcnQnIGluIG9wdGlvbnMucG9zaXRpb24gfHwgJ2luZGVudCcgaW4gb3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcG9pbnRzIGRvbuKAmXQgaGF2ZSBpbmRlbnQuXG4gICAgICBpbmRlbnQgPSBvcHRpb25zLnBvc2l0aW9uLmluZGVudFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcG9pbnRzIGRvbuKAmXQgaGF2ZSBpbmRlbnQuXG4gICAgICBwb2ludCA9IG9wdGlvbnMucG9zaXRpb24uc3RhcnRcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnQgPSBvcHRpb25zLnBvc2l0aW9uXG4gICAgfVxuICB9XG5cbiAgbGV0IGxpbmUgPSAocG9pbnQgPyBwb2ludC5saW5lIDogMCkgfHwgMVxuICBsZXQgY29sdW1uID0gKHBvaW50ID8gcG9pbnQuY29sdW1uIDogMCkgfHwgMVxuXG4gIC8vIENhY2hlIHRoZSBjdXJyZW50IHBvaW50LlxuICBsZXQgcHJldmlvdXMgPSBub3coKVxuICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gIGxldCBjaGFyYWN0ZXJcblxuICAvLyBFbnN1cmUgdGhlIGFsZ29yaXRobSB3YWxrcyBvdmVyIHRoZSBmaXJzdCBjaGFyYWN0ZXIgKGluY2x1c2l2ZSkuXG4gIGluZGV4LS1cblxuICB3aGlsZSAoKytpbmRleCA8PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIG5ld2xpbmUuXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gMTAgLyogYFxcbmAgKi8pIHtcbiAgICAgIGNvbHVtbiA9IChpbmRlbnQgPyBpbmRlbnRbbGluZXNdIDogMCkgfHwgMVxuICAgIH1cblxuICAgIGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpXG5cbiAgICBpZiAoY2hhcmFjdGVyID09PSAzOCAvKiBgJmAgKi8pIHtcbiAgICAgIGNvbnN0IGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXggKyAxKVxuXG4gICAgICAvLyBUaGUgYmVoYXZpb3IgZGVwZW5kcyBvbiB0aGUgaWRlbnRpdHkgb2YgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgaWYgKFxuICAgICAgICBmb2xsb3dpbmcgPT09IDkgLyogYFxcdGAgKi8gfHxcbiAgICAgICAgZm9sbG93aW5nID09PSAxMCAvKiBgXFxuYCAqLyB8fFxuICAgICAgICBmb2xsb3dpbmcgPT09IDEyIC8qIGBcXGZgICovIHx8XG4gICAgICAgIGZvbGxvd2luZyA9PT0gMzIgLyogYCBgICovIHx8XG4gICAgICAgIGZvbGxvd2luZyA9PT0gMzggLyogYCZgICovIHx8XG4gICAgICAgIGZvbGxvd2luZyA9PT0gNjAgLyogYDxgICovIHx8XG4gICAgICAgIE51bWJlci5pc05hTihmb2xsb3dpbmcpIHx8XG4gICAgICAgIChhZGRpdGlvbmFsICYmIGZvbGxvd2luZyA9PT0gYWRkaXRpb25hbClcbiAgICAgICkge1xuICAgICAgICAvLyBOb3QgYSBjaGFyYWN0ZXIgcmVmZXJlbmNlLlxuICAgICAgICAvLyBObyBjaGFyYWN0ZXJzIGFyZSBjb25zdW1lZCwgYW5kIG5vdGhpbmcgaXMgcmV0dXJuZWQuXG4gICAgICAgIC8vIFRoaXMgaXMgbm90IGFuIGVycm9yLCBlaXRoZXIuXG4gICAgICAgIHF1ZXVlICs9IGZyb21DaGFyQ29kZShjaGFyYWN0ZXIpXG4gICAgICAgIGNvbHVtbisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBsZXQgYmVnaW4gPSBzdGFydFxuICAgICAgbGV0IGVuZCA9IHN0YXJ0XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCB0eXBlXG5cbiAgICAgIGlmIChmb2xsb3dpbmcgPT09IDM1IC8qIGAjYCAqLykge1xuICAgICAgICAvLyBOdW1lcmljYWwgcmVmZXJlbmNlLlxuICAgICAgICBlbmQgPSArK2JlZ2luXG5cbiAgICAgICAgLy8gVGhlIGJlaGF2aW9yIGZ1cnRoZXIgZGVwZW5kcyBvbiB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKVxuXG4gICAgICAgIGlmIChmb2xsb3dpbmcgPT09IDg4IC8qIGBYYCAqLyB8fCBmb2xsb3dpbmcgPT09IDEyMCAvKiBgeGAgKi8pIHtcbiAgICAgICAgICAvLyBBU0NJSSBoZXhhZGVjaW1hbCBkaWdpdHMuXG4gICAgICAgICAgdHlwZSA9ICdoZXhhZGVjaW1hbCdcbiAgICAgICAgICBlbmQgPSArK2JlZ2luXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQVNDSUkgZGVjaW1hbCBkaWdpdHMuXG4gICAgICAgICAgdHlwZSA9ICdkZWNpbWFsJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOYW1lZCByZWZlcmVuY2UuXG4gICAgICAgIHR5cGUgPSAnbmFtZWQnXG4gICAgICB9XG5cbiAgICAgIGxldCBjaGFyYWN0ZXJSZWZlcmVuY2VDaGFyYWN0ZXJzID0gJydcbiAgICAgIGxldCBjaGFyYWN0ZXJSZWZlcmVuY2UgPSAnJ1xuICAgICAgbGV0IGNoYXJhY3RlcnMgPSAnJ1xuICAgICAgLy8gRWFjaCB0eXBlIG9mIGNoYXJhY3RlciByZWZlcmVuY2UgYWNjZXB0cyBkaWZmZXJlbnQgY2hhcmFjdGVycy5cbiAgICAgIC8vIFRoaXMgdGVzdCBpcyB1c2VkIHRvIGRldGVjdCB3aGV0aGVyIGEgcmVmZXJlbmNlIGhhcyBlbmRlZCAoYXMgdGhlIHNlbWljb2xvblxuICAgICAgLy8gaXMgbm90IHN0cmljdGx5IG5lZWRlZCkuXG4gICAgICBjb25zdCB0ZXN0ID1cbiAgICAgICAgdHlwZSA9PT0gJ25hbWVkJ1xuICAgICAgICAgID8gaXNBbHBoYW51bWVyaWNhbFxuICAgICAgICAgIDogdHlwZSA9PT0gJ2RlY2ltYWwnXG4gICAgICAgICAgPyBpc0RlY2ltYWxcbiAgICAgICAgICA6IGlzSGV4YWRlY2ltYWxcblxuICAgICAgZW5kLS1cblxuICAgICAgd2hpbGUgKCsrZW5kIDw9IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmb2xsb3dpbmcgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZClcblxuICAgICAgICBpZiAoIXRlc3QoZm9sbG93aW5nKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjaGFyYWN0ZXJzICs9IGZyb21DaGFyQ29kZShmb2xsb3dpbmcpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIG1hdGNoIGEgbGVnYWN5IG5hbWVkIHJlZmVyZW5jZS5cbiAgICAgICAgLy8gSWYgc28sIHdlIGNhY2hlIHRoYXQgYXMgdGhlIGxhc3QgdmlhYmxlIG5hbWVkIHJlZmVyZW5jZS5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvIG5vdCBuZWVkIHRvIHdhbGsgYmFja3dhcmRzIGxhdGVyLlxuICAgICAgICBpZiAodHlwZSA9PT0gJ25hbWVkJyAmJiBjaGFyYWN0ZXJFbnRpdGllc0xlZ2FjeS5pbmNsdWRlcyhjaGFyYWN0ZXJzKSkge1xuICAgICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnMgPSBjaGFyYWN0ZXJzXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYWx3YXlzIGFibGUgdG8gZGVjb2RlLlxuICAgICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZSA9IGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKGNoYXJhY3RlcnMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHRlcm1pbmF0ZWQgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZCkgPT09IDU5IC8qIGA7YCAqL1xuXG4gICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICBlbmQrK1xuXG4gICAgICAgIGNvbnN0IG5hbWVkUmVmZXJlbmNlID1cbiAgICAgICAgICB0eXBlID09PSAnbmFtZWQnID8gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoY2hhcmFjdGVycykgOiBmYWxzZVxuXG4gICAgICAgIGlmIChuYW1lZFJlZmVyZW5jZSkge1xuICAgICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnMgPSBjaGFyYWN0ZXJzXG4gICAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlID0gbmFtZWRSZWZlcmVuY2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGlmZiA9IDEgKyBlbmQgLSBzdGFydFxuICAgICAgbGV0IHJlZmVyZW5jZSA9ICcnXG5cbiAgICAgIGlmICghdGVybWluYXRlZCAmJiBvcHRpb25zLm5vblRlcm1pbmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIEVtcHR5LlxuICAgICAgfSBlbHNlIGlmICghY2hhcmFjdGVycykge1xuICAgICAgICAvLyBBbiBlbXB0eSAocG9zc2libGUpIHJlZmVyZW5jZSBpcyB2YWxpZCwgdW5sZXNzIGl04oCZcyBudW1lcmljICh0aHVzIGFuXG4gICAgICAgIC8vIGFtcGVyc2FuZCBmb2xsb3dlZCBieSBhbiBvY3RvdGhvcnApLlxuICAgICAgICBpZiAodHlwZSAhPT0gJ25hbWVkJykge1xuICAgICAgICAgIHdhcm5pbmcoNCAvKiBFbXB0eSAobnVtZXJpYykgKi8sIGRpZmYpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWVkJykge1xuICAgICAgICAvLyBBbiBhbXBlcnNhbmQgZm9sbG93ZWQgYnkgYW55dGhpbmcgdW5rbm93biwgYW5kIG5vdCB0ZXJtaW5hdGVkLCBpc1xuICAgICAgICAvLyBpbnZhbGlkLlxuICAgICAgICBpZiAodGVybWluYXRlZCAmJiAhY2hhcmFjdGVyUmVmZXJlbmNlKSB7XG4gICAgICAgICAgd2FybmluZyg1IC8qIFVua25vd24gKG5hbWVkKSAqLywgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZeKAmXMgc29tZXRoaW5nIGFmdGVyIGFuIG5hbWVkIHJlZmVyZW5jZSB3aGljaCBpcyBub3Qga25vd24sXG4gICAgICAgICAgLy8gY2FwIHRoZSByZWZlcmVuY2UuXG4gICAgICAgICAgaWYgKGNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnMgIT09IGNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGVuZCA9IGJlZ2luICsgY2hhcmFjdGVyUmVmZXJlbmNlQ2hhcmFjdGVycy5sZW5ndGhcbiAgICAgICAgICAgIGRpZmYgPSAxICsgZW5kIC0gYmVnaW5cbiAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgbm90IHRlcm1pbmF0ZWQsIHdhcm4uXG4gICAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWFzb24gPSBjaGFyYWN0ZXJSZWZlcmVuY2VDaGFyYWN0ZXJzXG4gICAgICAgICAgICAgID8gMSAvKiBOb24gdGVybWluYXRlZCAobmFtZWQpICovXG4gICAgICAgICAgICAgIDogMyAvKiBFbXB0eSAobmFtZWQpICovXG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICBjb25zdCBmb2xsb3dpbmcgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZClcblxuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nID09PSA2MSAvKiBgPWAgKi8pIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nKHJlYXNvbiwgZGlmZilcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJSZWZlcmVuY2UgPSAnJ1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQWxwaGFudW1lcmljYWwoZm9sbG93aW5nKSkge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZSA9ICcnXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybmluZyhyZWFzb24sIGRpZmYpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcocmVhc29uLCBkaWZmKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZmVyZW5jZSA9IGNoYXJhY3RlclJlZmVyZW5jZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgLy8gQWxsIG5vbnRlcm1pbmF0ZWQgbnVtZXJpYyByZWZlcmVuY2VzIGFyZSBub3QgcmVuZGVyZWQsIGFuZCBlbWl0IGFcbiAgICAgICAgICAvLyB3YXJuaW5nLlxuICAgICAgICAgIHdhcm5pbmcoMiAvKiBOb24gdGVybWluYXRlZCAobnVtZXJpYykgKi8sIGRpZmYpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHRlcm1pbmF0ZWQgYW5kIG51bWVyaWNhbCwgcGFyc2UgYXMgZWl0aGVyIGhleGFkZWNpbWFsIG9yXG4gICAgICAgIC8vIGRlY2ltYWwuXG4gICAgICAgIGxldCByZWZlcmVuY2VDb2RlID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgIGNoYXJhY3RlcnMsXG4gICAgICAgICAgdHlwZSA9PT0gJ2hleGFkZWNpbWFsJyA/IDE2IDogMTBcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIEVtaXQgYSB3YXJuaW5nIHdoZW4gdGhlIHBhcnNlZCBudW1iZXIgaXMgcHJvaGliaXRlZCwgYW5kIHJlcGxhY2Ugd2l0aFxuICAgICAgICAvLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChwcm9oaWJpdGVkKHJlZmVyZW5jZUNvZGUpKSB7XG4gICAgICAgICAgd2FybmluZyg3IC8qIFByb2hpYml0ZWQgKG51bWVyaWMpICovLCBkaWZmKVxuICAgICAgICAgIHJlZmVyZW5jZSA9IGZyb21DaGFyQ29kZSg2NTUzMyAvKiBg77+9YCAqLylcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2VDb2RlIGluIGNoYXJhY3RlclJlZmVyZW5jZUludmFsaWQpIHtcbiAgICAgICAgICAvLyBFbWl0IGEgd2FybmluZyB3aGVuIHRoZSBwYXJzZWQgbnVtYmVyIGlzIGRpc2FsbG93ZWQsIGFuZCByZXBsYWNlIGJ5XG4gICAgICAgICAgLy8gYW4gYWx0ZXJuYXRpdmUuXG4gICAgICAgICAgd2FybmluZyg2IC8qIERpc2FsbG93ZWQgKG51bWVyaWMpICovLCBkaWZmKVxuICAgICAgICAgIHJlZmVyZW5jZSA9IGNoYXJhY3RlclJlZmVyZW5jZUludmFsaWRbcmVmZXJlbmNlQ29kZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJzZSB0aGUgbnVtYmVyLlxuICAgICAgICAgIGxldCBvdXRwdXQgPSAnJ1xuXG4gICAgICAgICAgLy8gRW1pdCBhIHdhcm5pbmcgd2hlbiB0aGUgcGFyc2VkIG51bWJlciBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICAgICAgaWYgKGRpc2FsbG93ZWQocmVmZXJlbmNlQ29kZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoNiAvKiBEaXNhbGxvd2VkIChudW1lcmljKSAqLywgZGlmZilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIG51bWJlci5cbiAgICAgICAgICBpZiAocmVmZXJlbmNlQ29kZSA+IDB4ZmZmZikge1xuICAgICAgICAgICAgcmVmZXJlbmNlQ29kZSAtPSAweDEwMDAwXG4gICAgICAgICAgICBvdXRwdXQgKz0gZnJvbUNoYXJDb2RlKChyZWZlcmVuY2VDb2RlID4+PiAoMTAgJiAweDNmZikpIHwgMHhkODAwKVxuICAgICAgICAgICAgcmVmZXJlbmNlQ29kZSA9IDB4ZGMwMCB8IChyZWZlcmVuY2VDb2RlICYgMHgzZmYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVmZXJlbmNlID0gb3V0cHV0ICsgZnJvbUNoYXJDb2RlKHJlZmVyZW5jZUNvZGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRm91bmQgaXQhXG4gICAgICAvLyBGaXJzdCBlYXQgdGhlIHF1ZXVlZCBjaGFyYWN0ZXJzIGFzIG5vcm1hbCB0ZXh0LCB0aGVuIGVhdCBhIHJlZmVyZW5jZS5cbiAgICAgIGlmIChyZWZlcmVuY2UpIHtcbiAgICAgICAgZmx1c2goKVxuXG4gICAgICAgIHByZXZpb3VzID0gbm93KClcbiAgICAgICAgaW5kZXggPSBlbmQgLSAxXG4gICAgICAgIGNvbHVtbiArPSBlbmQgLSBzdGFydCArIDFcbiAgICAgICAgcmVzdWx0LnB1c2gocmVmZXJlbmNlKVxuICAgICAgICBjb25zdCBuZXh0ID0gbm93KClcbiAgICAgICAgbmV4dC5vZmZzZXQrK1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSkge1xuICAgICAgICAgIG9wdGlvbnMucmVmZXJlbmNlLmNhbGwoXG4gICAgICAgICAgICBvcHRpb25zLnJlZmVyZW5jZUNvbnRleHQsXG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICB7c3RhcnQ6IHByZXZpb3VzLCBlbmQ6IG5leHR9LFxuICAgICAgICAgICAgdmFsdWUuc2xpY2Uoc3RhcnQgLSAxLCBlbmQpXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXMgPSBuZXh0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHJlZmVyZW5jZSwgcXVldWUgdGhlIGNoZWNrZWQgY2hhcmFjdGVycyAoYXNcbiAgICAgICAgLy8gbm9ybWFsIGNoYXJhY3RlcnMpLCBhbmQgbW92ZSB0aGUgcG9pbnRlciB0byB0aGVpciBlbmQuXG4gICAgICAgIC8vIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSB3ZSBjYW4gYmUgY2VydGFpbiBuZWl0aGVyIG5ld2xpbmVzIG5vclxuICAgICAgICAvLyBhbXBlcnNhbmRzIGFyZSBpbmNsdWRlZC5cbiAgICAgICAgY2hhcmFjdGVycyA9IHZhbHVlLnNsaWNlKHN0YXJ0IC0gMSwgZW5kKVxuICAgICAgICBxdWV1ZSArPSBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbHVtbiArPSBjaGFyYWN0ZXJzLmxlbmd0aFxuICAgICAgICBpbmRleCA9IGVuZCAtIDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gYW1wZXJzYW5kLCBpbmNsdWRpbmcgbmV3bGluZXMgYW5kIEVPRi5cbiAgICAgIGlmIChjaGFyYWN0ZXIgPT09IDEwIC8qIGBcXG5gICovKSB7XG4gICAgICAgIGxpbmUrK1xuICAgICAgICBsaW5lcysrXG4gICAgICAgIGNvbHVtbiA9IDBcbiAgICAgIH1cblxuICAgICAgaWYgKE51bWJlci5pc05hTihjaGFyYWN0ZXIpKSB7XG4gICAgICAgIGZsdXNoKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlICs9IGZyb21DaGFyQ29kZShjaGFyYWN0ZXIpXG4gICAgICAgIGNvbHVtbisrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSByZWR1Y2VkIG5vZGVzLlxuICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG5cbiAgLy8gR2V0IGN1cnJlbnQgcG9zaXRpb24uXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbixcbiAgICAgIG9mZnNldDogaW5kZXggKyAoKHBvaW50ID8gcG9pbnQub2Zmc2V0IDogMCkgfHwgMClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gezF8MnwzfDR8NXw2fDd9IGNvZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgZnVuY3Rpb24gd2FybmluZyhjb2RlLCBvZmZzZXQpIHtcbiAgICAvKiogQHR5cGUge1JldHVyblR5cGU8bm93Pn0gKi9cbiAgICBsZXQgcG9zaXRpb25cblxuICAgIGlmIChvcHRpb25zLndhcm5pbmcpIHtcbiAgICAgIHBvc2l0aW9uID0gbm93KClcbiAgICAgIHBvc2l0aW9uLmNvbHVtbiArPSBvZmZzZXRcbiAgICAgIHBvc2l0aW9uLm9mZnNldCArPSBvZmZzZXRcblxuICAgICAgb3B0aW9ucy53YXJuaW5nLmNhbGwoXG4gICAgICAgIG9wdGlvbnMud2FybmluZ0NvbnRleHQsXG4gICAgICAgIG1lc3NhZ2VzW2NvZGVdLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgY29kZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBgcXVldWVgIChub3JtYWwgdGV4dCkuXG4gICAqIE1hY3JvIGludm9rZWQgYmVmb3JlIGVhY2ggcmVmZXJlbmNlIGFuZCBhdCB0aGUgZW5kIG9mIGB2YWx1ZWAuXG4gICAqIERvZXMgbm90aGluZyB3aGVuIGBxdWV1ZWAgaXMgZW1wdHkuXG4gICAqL1xuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAocXVldWUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHF1ZXVlKVxuXG4gICAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMudGV4dC5jYWxsKG9wdGlvbnMudGV4dENvbnRleHQsIHF1ZXVlLCB7XG4gICAgICAgICAgc3RhcnQ6IHByZXZpb3VzLFxuICAgICAgICAgIGVuZDogbm93KClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcXVldWUgPSAnJ1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBjaGFyYWN0ZXJgIGlzIG91dHNpZGUgdGhlIHBlcm1pc3NpYmxlIHVuaWNvZGUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBwcm9oaWJpdGVkKGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGZmZikgfHwgY29kZSA+IDB4MTBmZmZmXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYGNoYXJhY3RlcmAgaXMgZGlzYWxsb3dlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRpc2FsbG93ZWQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDB4MDAwMSAmJiBjb2RlIDw9IDB4MDAwOCkgfHxcbiAgICBjb2RlID09PSAweDAwMGIgfHxcbiAgICAoY29kZSA+PSAweDAwMGQgJiYgY29kZSA8PSAweDAwMWYpIHx8XG4gICAgKGNvZGUgPj0gMHgwMDdmICYmIGNvZGUgPD0gMHgwMDlmKSB8fFxuICAgIChjb2RlID49IDB4ZmRkMCAmJiBjb2RlIDw9IDB4ZmRlZikgfHxcbiAgICAoY29kZSAmIDB4ZmZmZikgPT09IDB4ZmZmZiB8fFxuICAgIChjb2RlICYgMHhmZmZmKSA9PT0gMHhmZmZlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJFbnRpdGllc0xlZ2FjeSIsImNoYXJhY3RlclJlZmVyZW5jZUludmFsaWQiLCJpc0RlY2ltYWwiLCJpc0hleGFkZWNpbWFsIiwiaXNBbHBoYW51bWVyaWNhbCIsImRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlIiwiZnJvbUNoYXJDb2RlIiwiU3RyaW5nIiwibWVzc2FnZXMiLCJwYXJzZUVudGl0aWVzIiwidmFsdWUiLCJvcHRpb25zIiwiYWRkaXRpb25hbCIsImNoYXJDb2RlQXQiLCJyZXN1bHQiLCJpbmRleCIsImxpbmVzIiwicXVldWUiLCJwb2ludCIsImluZGVudCIsInBvc2l0aW9uIiwic3RhcnQiLCJsaW5lIiwiY29sdW1uIiwicHJldmlvdXMiLCJub3ciLCJjaGFyYWN0ZXIiLCJsZW5ndGgiLCJmb2xsb3dpbmciLCJOdW1iZXIiLCJpc05hTiIsImJlZ2luIiwiZW5kIiwidHlwZSIsImNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnMiLCJjaGFyYWN0ZXJSZWZlcmVuY2UiLCJjaGFyYWN0ZXJzIiwidGVzdCIsImluY2x1ZGVzIiwidGVybWluYXRlZCIsIm5hbWVkUmVmZXJlbmNlIiwiZGlmZiIsInJlZmVyZW5jZSIsIm5vblRlcm1pbmF0ZWQiLCJ3YXJuaW5nIiwicmVhc29uIiwiYXR0cmlidXRlIiwicmVmZXJlbmNlQ29kZSIsInBhcnNlSW50IiwicHJvaGliaXRlZCIsIm91dHB1dCIsImRpc2FsbG93ZWQiLCJmbHVzaCIsInB1c2giLCJuZXh0Iiwib2Zmc2V0IiwiY2FsbCIsInJlZmVyZW5jZUNvbnRleHQiLCJzbGljZSIsImpvaW4iLCJjb2RlIiwid2FybmluZ0NvbnRleHQiLCJ0ZXh0IiwidGV4dENvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/parse-entities/lib/index.js\n");

/***/ })

};
;